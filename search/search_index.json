{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Music Interaction Systems Demo/Performance/Tryout @ LNDW 18:00 - 24:00 A TU Studio Project (Audio Communication Group). At TU Studio , students, scientists and musicians are exploring the possibilities of so called meta-instruments. Intelligent networks are used to connect arbitrary musical instruments, giving rise to novel possibilities in composition and performance. At LNDW, Students will present compositions and improvisations from class in an open environment. The audience is invited to move freely, listen, ask questions and interact with the system [ More Info ]. Find these pages: nsmi.ringbuffer.org","title":"Home"},{"location":"#music-interaction-systems","text":"Demo/Performance/Tryout @ LNDW 18:00 - 24:00 A TU Studio Project (Audio Communication Group). At TU Studio , students, scientists and musicians are exploring the possibilities of so called meta-instruments. Intelligent networks are used to connect arbitrary musical instruments, giving rise to novel possibilities in composition and performance. At LNDW, Students will present compositions and improvisations from class in an open environment. The audience is invited to move freely, listen, ask questions and interact with the system [ More Info ]. Find these pages: nsmi.ringbuffer.org","title":"Music Interaction Systems"},{"location":"about/","text":"Jack & JackTrip Jack Jack is a sound server API, which connects different audio applications. Each Rasperry PI runs a Jack server. JackTrip JackTrip is a network audio protocol. It connects the Jack servers of all Rasperry PIs via ethernet. This image shows all Jack clients on a single Rasperry PI with an additional processing tool (scyclone). To this point, only scyclone is connected: Ring Topology The ring topology connects each access point with two other access points, thus creating a closed loop. A signal can then travel around all PIs. For the scyclone piece, the connections look like this: WORK/2023_Music_Interaction_Systems/Public_Docs/docs/graphics/.png Fully Connected Mesh In a fully connected mesh, every access point is connected to all other access points. The camera tracking project uses this connection graph:","title":"Jack + JackTrip"},{"location":"about/#jack-jacktrip","text":"","title":"Jack &amp; JackTrip"},{"location":"about/#jack","text":"Jack is a sound server API, which connects different audio applications. Each Rasperry PI runs a Jack server.","title":"Jack"},{"location":"about/#jacktrip","text":"JackTrip is a network audio protocol. It connects the Jack servers of all Rasperry PIs via ethernet. This image shows all Jack clients on a single Rasperry PI with an additional processing tool (scyclone). To this point, only scyclone is connected:","title":"JackTrip"},{"location":"about/#ring-topology","text":"The ring topology connects each access point with two other access points, thus creating a closed loop. A signal can then travel around all PIs. For the scyclone piece, the connections look like this: WORK/2023_Music_Interaction_Systems/Public_Docs/docs/graphics/.png","title":"Ring Topology"},{"location":"about/#fully-connected-mesh","text":"In a fully connected mesh, every access point is connected to all other access points. The camera tracking project uses this connection graph:","title":"Fully Connected Mesh"},{"location":"ansible/","text":"Raspberry Pi setup I've used the Raspberry Pi Imager utility to flash the Raspberry Pi SD cards. The tool allows you to set an initial wifi, user, password, and host name. I used Raspberry Pi OS Lite (64-bit) as a starting point. This is a minimal distribution, which allows us to install only the packages we need. The following scheme for names, hostnames and passwords can be used for a consistent setup: Username: nodeA Hostname: nodeA Password: knotenA Note: Only use this password scheme if the nodes are not connected to a public network. However, after you copied the ssh key (next step) you can disable ssh login via password, as described here . You could do this temporarily, since the Pis require an internet connection during the ansible setup. The letter A is then replaced for each node by incrementing the letter. After the image is flashed, we copy our public ssh key to each Raspberry Pi using ssh-copy-id : ssh-copy-id nodeA@nodeA.local After this, the setup process is automated using Ansible. The configuration files are in this repository's ansible subfolder. Ansible Config Currently, these are only used to save some time running commands. ansible.cfg only contains two options: [defaults] INVENTORY = inventory [ssh_connection] pipelining = True The first line sets the default \"inventory\" file, which contains the username@host for all Raspberry Pis which should be setup using Ansible. The second option pipelining = True enables pipelining via ssh: Pipelining, if supported by the connection plugin, reduces the number of network operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfer. It can result in a very significant performance improvement when enabled. However this conflicts with privilege escalation (become). For example, when using \u2018sudo:\u2019 operations you must first disable \u2018requiretty\u2019 in /etc/sudoers on all managed hosts, which is why it is disabled by default. This setting will be disabled if ANSIBLE_KEEP_REMOTE_FILES is enabled. Note that I don't remember explicitly disabling requiretty on the Pis, so it might be the default. However, if there are problems with privilege you can try disabling this option. General Setup Software Overview The setup.yml file contains a general setup for the Pis, making sure that the hardware is set up correctly and everything is up to date. The following software is installed: lightdm, lxsession : Lightweight display manager lxde supercollider, sc3-plugins supercollider jackd2 Jack audio python3-pip, git Requirements for p2psc xinput I'm not quite sure whether this is still necessary.. LXDE The following command enables automatic login (so no password is required) after boot: raspi-config nonint do_boot_behaviour B4 As you may notice, the screen rotation is wrong, so we need to configure LXDE to flip the screen. This requires a reboot (which is done automatically), after which the LXDE configuration files are created. To rotate the screen, a script is run after every boot which executes some xrandr commands to rotate the screen and touchscreen #!/bin/bash DISPLAY = :0 xrandr -o inverted DISPLAY = :0 xinput --set-prop \"generic ft5x06 (79)\" \"Coordinate Transformation Matrix\" -1 0 1 0 -1 1 0 0 1 Keyboard layout Is set to German by default, since the keyboards at TU are all German. Jack Audio The following is required to allow jack audio real-time scheduling, see here : - name: Add user to audio group and enable jack limits config hosts: p2psc tags: jack tasks: - shell: usermod -a -G audio {{ ansible_user_id }} become: true - copy: remote_src=True src=/etc/security/limits.d/audio.conf.disabled dest=/etc/security/limits.d/audio.conf become: true Additionally, a script is created that automatically starts jack audio in a terminal after boot: /usr/bin/jackd -P75 -dalsa -dhw:1 -p512 -n3 -s -r44100 2 > & 1 & P2PSC Clones the p2psc repository ( ~/p2psc ) and creates a script to automatically run p2psc in a terminal window after boot. There is also a 10s delay, to wait for a DHCP lease if a server is present: #!/bin/bash echo \"Waiting for DHCP/AutoIP init...\" sleep 10 ; PYTHONPATH = ~/p2psc/ python3 ~/p2psc/p2psc/main.py -v This is required since p2psc automatically detects the IP address. If p2psc is started immediately after boot, it will use an AUTO-IP address, which will lead to issues in a DHCP enabled network. Additionally, the setup creates a p2psc configuration file with the \"name\" set to each host's host name: { \"name\" : \"{{ ansible_user_id }}\" , \"zeroconf\" : true , \"ip\" : null , \"port\" : 3760 } Supercollider Since we want to use the p2psc supercollider library, a config file for supercollider is created: ~/.config/SuperCollider/sclang_conf.yaml includePaths : - ~/p2psc/libs/sclang excludePaths : [] postInlineWarnings : false Jacktrip Setup Note that this has not been tested for a while and was only a proof of concept. So take it with a grain of salt ;) jacktrip When I created this script, the jacktrip provided in the Ubuntu repositories was missing some essential features, which is why I created an extra step to clone and compile a more recent version of jacktrip. This might not be necessary anymore! jack-matchmaker Creates a systemd service that runs jack-matchmaker in the background. This allows us to automatically connect certain jack clients with others. Since we can update the configuration while this script is running, we can dynamically change the connections it makes. This allows us to map jack and jacktrip channels in a sensible manner. Supercollider We also create a supercollider startup file, which sets the number of SC channels to 12 by default: ~/.config/SuperCollider/startup.scd s.options.numInputBusChannels = 12; s.options.numOutputBusChannels = 12; Note: That the number of channels must match or exceed the number of nodes in the network + Output channels! Connection Setup Note that this requires some manual intervention since the jack to jacktrip port mapping is not implemented dynamically. This is the current default mapping of nodes to supercollider ports: nodeA:receive_1 SuperCollider:in_3 SuperCollider:out_3 nodeA:send_1 nodeB:receive_1 SuperCollider:in_4 SuperCollider:out_4 nodeB:send_1 nodeC:receive_1 SuperCollider:in_5 SuperCollider:out_5 nodeC:send_1 nodeD:receive_1 SuperCollider:in_6 SuperCollider:out_6 nodeD:send_1 nodeE:receive_1 SuperCollider:in_7 SuperCollider:out_7 nodeE:send_1 nodeF:receive_1 SuperCollider:in_8 SuperCollider:out_8 nodeF:send_1 nodeG:receive_1 SuperCollider:in_9 SuperCollider:out_9 nodeG:send_1 nodeH:receive_1 SuperCollider:in_10 SuperCollider:out_10 nodeH:send_1 The connection establishment is \"semi-automatic\" and uses the Ansible inventory to determine which connections need to be made. In a fixed setup, the script used here could be run after boot and automatically create all jackrip connections. Since this was more of a proof-of-concept, this is a bit hacky, but it worked if I remember correctly ;) First, we create a list of other hosts for each node. This might a bit tricky to grasp, but we only want to create connections in one direction (which then are bidirectional). This means, not every node connects to every other node. This script creates a subset of nodes for each node to achieve this: Example hosts [A,B,C,D]: + A connects to [B,C,D] + B connects to [C,D] + C connects to [D] + D connects to [] (none) Which results in a fully connected graph ownIndex ={{ play_hosts.index ( inventory_hostname ) }} index ={{ index }} echo \" $ownIndex $index \" >> /home/ {{ ansible_user_id }} /test if [ \" $ownIndex \" -lt \" $index \" ] ; then item ={{ item }} remote_host_addr = ${ item #*@ } remote_host = ${ remote_host_addr %%.* } echo -n \" $remote_host \" >> /home/ {{ ansible_user_id }} /.jacktrip_connections ; fi This file is then used in a script to create a jacktrip hub instance and establish all connections: #!/bin/bash # start jacktrip server in hub (-S) mode for incoming connections # and disable default connections (-D) jacktrip -S -D > /dev/null 2 > & 1 & # wait 5 seconds to make sure all hubs are started sleep 5 ; # Go through list of hosts and establish connections hosts = $( cat /home/ {{ ansible_user_id }} /.jacktrip_connections ) port = 4464 for h in $hosts ; do # create a 1-channel connection to each host (-n1) jacktrip -C ${ h } .local -J $h -K {{ ansible_user_id }} -n1 -D -B ${ port } > /dev/null 2 > & 1 & (( port = port+1 )) done Running Ansible From within the ansible subfolder , run the following command: ansible-playbook setup.yml Note: Make sure that the inventory file in the ansible subfolder contains a line for each node you want to set up (e.g. nodeA@nodeA.local || \\<user>@\\<hostname>.local) Running Jacktrip Note that this is untested but should work! Run the jacktrip connect script created during the jacktrip_setup: ansible p2psc -m shell -a \"nohup ~/scripts/jt_connect.sh &\" Kill all jacktrip instances ansible p2psc -m shell -a \"killall jacktrip&\"","title":"Ansible"},{"location":"ansible/#raspberry-pi-setup","text":"I've used the Raspberry Pi Imager utility to flash the Raspberry Pi SD cards. The tool allows you to set an initial wifi, user, password, and host name. I used Raspberry Pi OS Lite (64-bit) as a starting point. This is a minimal distribution, which allows us to install only the packages we need. The following scheme for names, hostnames and passwords can be used for a consistent setup: Username: nodeA Hostname: nodeA Password: knotenA Note: Only use this password scheme if the nodes are not connected to a public network. However, after you copied the ssh key (next step) you can disable ssh login via password, as described here . You could do this temporarily, since the Pis require an internet connection during the ansible setup. The letter A is then replaced for each node by incrementing the letter. After the image is flashed, we copy our public ssh key to each Raspberry Pi using ssh-copy-id : ssh-copy-id nodeA@nodeA.local After this, the setup process is automated using Ansible. The configuration files are in this repository's ansible subfolder.","title":"Raspberry Pi setup"},{"location":"ansible/#ansible","text":"","title":"Ansible"},{"location":"ansible/#config","text":"Currently, these are only used to save some time running commands. ansible.cfg only contains two options: [defaults] INVENTORY = inventory [ssh_connection] pipelining = True The first line sets the default \"inventory\" file, which contains the username@host for all Raspberry Pis which should be setup using Ansible. The second option pipelining = True enables pipelining via ssh: Pipelining, if supported by the connection plugin, reduces the number of network operations required to execute a module on the remote server, by executing many Ansible modules without actual file transfer. It can result in a very significant performance improvement when enabled. However this conflicts with privilege escalation (become). For example, when using \u2018sudo:\u2019 operations you must first disable \u2018requiretty\u2019 in /etc/sudoers on all managed hosts, which is why it is disabled by default. This setting will be disabled if ANSIBLE_KEEP_REMOTE_FILES is enabled. Note that I don't remember explicitly disabling requiretty on the Pis, so it might be the default. However, if there are problems with privilege you can try disabling this option.","title":"Config"},{"location":"ansible/#general-setup","text":"","title":"General Setup"},{"location":"ansible/#software-overview","text":"The setup.yml file contains a general setup for the Pis, making sure that the hardware is set up correctly and everything is up to date. The following software is installed: lightdm, lxsession : Lightweight display manager lxde supercollider, sc3-plugins supercollider jackd2 Jack audio python3-pip, git Requirements for p2psc xinput I'm not quite sure whether this is still necessary..","title":"Software Overview"},{"location":"ansible/#lxde","text":"The following command enables automatic login (so no password is required) after boot: raspi-config nonint do_boot_behaviour B4 As you may notice, the screen rotation is wrong, so we need to configure LXDE to flip the screen. This requires a reboot (which is done automatically), after which the LXDE configuration files are created. To rotate the screen, a script is run after every boot which executes some xrandr commands to rotate the screen and touchscreen #!/bin/bash DISPLAY = :0 xrandr -o inverted DISPLAY = :0 xinput --set-prop \"generic ft5x06 (79)\" \"Coordinate Transformation Matrix\" -1 0 1 0 -1 1 0 0 1","title":"LXDE"},{"location":"ansible/#keyboard-layout","text":"Is set to German by default, since the keyboards at TU are all German.","title":"Keyboard layout"},{"location":"ansible/#jack-audio","text":"The following is required to allow jack audio real-time scheduling, see here : - name: Add user to audio group and enable jack limits config hosts: p2psc tags: jack tasks: - shell: usermod -a -G audio {{ ansible_user_id }} become: true - copy: remote_src=True src=/etc/security/limits.d/audio.conf.disabled dest=/etc/security/limits.d/audio.conf become: true Additionally, a script is created that automatically starts jack audio in a terminal after boot: /usr/bin/jackd -P75 -dalsa -dhw:1 -p512 -n3 -s -r44100 2 > & 1 &","title":"Jack Audio"},{"location":"ansible/#p2psc","text":"Clones the p2psc repository ( ~/p2psc ) and creates a script to automatically run p2psc in a terminal window after boot. There is also a 10s delay, to wait for a DHCP lease if a server is present: #!/bin/bash echo \"Waiting for DHCP/AutoIP init...\" sleep 10 ; PYTHONPATH = ~/p2psc/ python3 ~/p2psc/p2psc/main.py -v This is required since p2psc automatically detects the IP address. If p2psc is started immediately after boot, it will use an AUTO-IP address, which will lead to issues in a DHCP enabled network. Additionally, the setup creates a p2psc configuration file with the \"name\" set to each host's host name: { \"name\" : \"{{ ansible_user_id }}\" , \"zeroconf\" : true , \"ip\" : null , \"port\" : 3760 }","title":"P2PSC"},{"location":"ansible/#supercollider","text":"Since we want to use the p2psc supercollider library, a config file for supercollider is created: ~/.config/SuperCollider/sclang_conf.yaml includePaths : - ~/p2psc/libs/sclang excludePaths : [] postInlineWarnings : false","title":"Supercollider"},{"location":"ansible/#jacktrip-setup","text":"Note that this has not been tested for a while and was only a proof of concept. So take it with a grain of salt ;)","title":"Jacktrip Setup"},{"location":"ansible/#jacktrip","text":"When I created this script, the jacktrip provided in the Ubuntu repositories was missing some essential features, which is why I created an extra step to clone and compile a more recent version of jacktrip. This might not be necessary anymore!","title":"jacktrip"},{"location":"ansible/#jack-matchmaker","text":"Creates a systemd service that runs jack-matchmaker in the background. This allows us to automatically connect certain jack clients with others. Since we can update the configuration while this script is running, we can dynamically change the connections it makes. This allows us to map jack and jacktrip channels in a sensible manner.","title":"jack-matchmaker"},{"location":"ansible/#supercollider_1","text":"We also create a supercollider startup file, which sets the number of SC channels to 12 by default: ~/.config/SuperCollider/startup.scd s.options.numInputBusChannels = 12; s.options.numOutputBusChannels = 12; Note: That the number of channels must match or exceed the number of nodes in the network + Output channels!","title":"Supercollider"},{"location":"ansible/#connection-setup","text":"Note that this requires some manual intervention since the jack to jacktrip port mapping is not implemented dynamically. This is the current default mapping of nodes to supercollider ports: nodeA:receive_1 SuperCollider:in_3 SuperCollider:out_3 nodeA:send_1 nodeB:receive_1 SuperCollider:in_4 SuperCollider:out_4 nodeB:send_1 nodeC:receive_1 SuperCollider:in_5 SuperCollider:out_5 nodeC:send_1 nodeD:receive_1 SuperCollider:in_6 SuperCollider:out_6 nodeD:send_1 nodeE:receive_1 SuperCollider:in_7 SuperCollider:out_7 nodeE:send_1 nodeF:receive_1 SuperCollider:in_8 SuperCollider:out_8 nodeF:send_1 nodeG:receive_1 SuperCollider:in_9 SuperCollider:out_9 nodeG:send_1 nodeH:receive_1 SuperCollider:in_10 SuperCollider:out_10 nodeH:send_1 The connection establishment is \"semi-automatic\" and uses the Ansible inventory to determine which connections need to be made. In a fixed setup, the script used here could be run after boot and automatically create all jackrip connections. Since this was more of a proof-of-concept, this is a bit hacky, but it worked if I remember correctly ;) First, we create a list of other hosts for each node. This might a bit tricky to grasp, but we only want to create connections in one direction (which then are bidirectional). This means, not every node connects to every other node. This script creates a subset of nodes for each node to achieve this: Example hosts [A,B,C,D]: + A connects to [B,C,D] + B connects to [C,D] + C connects to [D] + D connects to [] (none) Which results in a fully connected graph ownIndex ={{ play_hosts.index ( inventory_hostname ) }} index ={{ index }} echo \" $ownIndex $index \" >> /home/ {{ ansible_user_id }} /test if [ \" $ownIndex \" -lt \" $index \" ] ; then item ={{ item }} remote_host_addr = ${ item #*@ } remote_host = ${ remote_host_addr %%.* } echo -n \" $remote_host \" >> /home/ {{ ansible_user_id }} /.jacktrip_connections ; fi This file is then used in a script to create a jacktrip hub instance and establish all connections: #!/bin/bash # start jacktrip server in hub (-S) mode for incoming connections # and disable default connections (-D) jacktrip -S -D > /dev/null 2 > & 1 & # wait 5 seconds to make sure all hubs are started sleep 5 ; # Go through list of hosts and establish connections hosts = $( cat /home/ {{ ansible_user_id }} /.jacktrip_connections ) port = 4464 for h in $hosts ; do # create a 1-channel connection to each host (-n1) jacktrip -C ${ h } .local -J $h -K {{ ansible_user_id }} -n1 -D -B ${ port } > /dev/null 2 > & 1 & (( port = port+1 )) done","title":"Connection Setup"},{"location":"ansible/#running-ansible","text":"From within the ansible subfolder , run the following command: ansible-playbook setup.yml Note: Make sure that the inventory file in the ansible subfolder contains a line for each node you want to set up (e.g. nodeA@nodeA.local || \\<user>@\\<hostname>.local)","title":"Running Ansible"},{"location":"ansible/#running-jacktrip","text":"Note that this is untested but should work! Run the jacktrip connect script created during the jacktrip_setup: ansible p2psc -m shell -a \"nohup ~/scripts/jt_connect.sh &\" Kill all jacktrip instances ansible p2psc -m shell -a \"killall jacktrip&\"","title":"Running Jacktrip"},{"location":"ansible_getting_started/","text":"Getting started programs that should be installed: - Ansible - git Clone the sprawl repo: git clone git@github.com:ringbuffer-org/SPRAWL.git hosts/inventory hosts file contains all hosts that can be accessed by playbooks. [active_sprawl_nodes] AP-03 ansible_user = member AP-04 ansible_user = member AP-05 ansible_user = member AP-07 ansible_user = member AP-08 ansible_user = member AP-09 ansible_user = member AP-10 ansible_user = member AP-14 ansible_user = member AP-15 ansible_user = member AP-16 ansible_user = member [sprawl_nodes] AP-01.local ansible_user = member AP-0[3:9].local ansible_user = member AP-1[0:7].local ansible_user = member ansible.cfg is most easily found by ansible when it is in the same directory from which ansible commands are executed. config file that informs ansible about some default settings. [defaults] inventory = /path/to/hosts/file # inventory = hosts private_key_file = /path/to/private/key host_key_checking = false ssh keys asymetrical encryption keys, used for authentication Transfer own key to hosts: ansible-playbook pi_setup/playbooks/install_ssh_key.yml --ask-pass -e \"key=path/to/public/key.pub\" --fork = 14 Start Ansible Piece ansible-playbook Delay_Graph/launch_delay_ring.yml --fork 14","title":"Getting Started with Ansible"},{"location":"ansible_getting_started/#getting-started","text":"programs that should be installed: - Ansible - git Clone the sprawl repo: git clone git@github.com:ringbuffer-org/SPRAWL.git","title":"Getting started"},{"location":"ansible_getting_started/#hostsinventory","text":"hosts file contains all hosts that can be accessed by playbooks. [active_sprawl_nodes] AP-03 ansible_user = member AP-04 ansible_user = member AP-05 ansible_user = member AP-07 ansible_user = member AP-08 ansible_user = member AP-09 ansible_user = member AP-10 ansible_user = member AP-14 ansible_user = member AP-15 ansible_user = member AP-16 ansible_user = member [sprawl_nodes] AP-01.local ansible_user = member AP-0[3:9].local ansible_user = member AP-1[0:7].local ansible_user = member","title":"hosts/inventory"},{"location":"ansible_getting_started/#ansiblecfg","text":"is most easily found by ansible when it is in the same directory from which ansible commands are executed. config file that informs ansible about some default settings. [defaults] inventory = /path/to/hosts/file # inventory = hosts private_key_file = /path/to/private/key host_key_checking = false","title":"ansible.cfg"},{"location":"ansible_getting_started/#ssh-keys","text":"asymetrical encryption keys, used for authentication Transfer own key to hosts: ansible-playbook pi_setup/playbooks/install_ssh_key.yml --ask-pass -e \"key=path/to/public/key.pub\" --fork = 14","title":"ssh keys"},{"location":"ansible_getting_started/#start-ansible-piece","text":"ansible-playbook Delay_Graph/launch_delay_ring.yml --fork 14","title":"Start Ansible Piece"},{"location":"camera_tracking/","text":"Camera Tracking Concept and programming: Janek S\u00fc\u00df","title":"Camera Tracking"},{"location":"camera_tracking/#camera-tracking","text":"Concept and programming: Janek S\u00fc\u00df","title":"Camera Tracking"},{"location":"delay_ring/","text":"Delay Ring Concept and programming: Max Weidauer A distributed feedback-delay network.","title":"Delay Ring"},{"location":"delay_ring/#delay-ring","text":"Concept and programming: Max Weidauer A distributed feedback-delay network.","title":"Delay Ring"},{"location":"democratic_soundscapes/","text":"Democratic Sound Scapes Concept and programming: Kristof Konya MVP: Pi\u00b4s can vote via OSC to a central computer that does sound generation. The vote consists of X and Y values that can be selected via an X-Y pad. All the votes get combined on the central and sound is synthesized. The 4 corners represent 4 synthesized sounds that get morphed on the speakers depending on the current voting. Improvements: Clients have a visual indication of the current common vote. Change of vote gets represented stronger than static value holding, to increase movement in soundscapes and reduce the presence of overly averaged sounds.","title":"Democratic Soundscapes"},{"location":"democratic_soundscapes/#democratic-sound-scapes","text":"Concept and programming: Kristof Konya","title":"Democratic Sound Scapes"},{"location":"democratic_soundscapes/#mvp","text":"Pi\u00b4s can vote via OSC to a central computer that does sound generation. The vote consists of X and Y values that can be selected via an X-Y pad. All the votes get combined on the central and sound is synthesized. The 4 corners represent 4 synthesized sounds that get morphed on the speakers depending on the current voting.","title":"MVP:"},{"location":"democratic_soundscapes/#improvements","text":"Clients have a visual indication of the current common vote. Change of vote gets represented stronger than static value holding, to increase movement in soundscapes and reduce the presence of overly averaged sounds.","title":"Improvements:"},{"location":"filter_band/","text":"Filter Band Concept and programming: Henrik von Coler In filter_band, every PI runs a bandpass filter with adjustable center frequency and Q (via GUI). Every PI's input signal is routed to every other PI, processed by the filter and played through the speaker:","title":"Filter Band"},{"location":"filter_band/#filter-band","text":"Concept and programming: Henrik von Coler In filter_band, every PI runs a bandpass filter with adjustable center frequency and Q (via GUI). Every PI's input signal is routed to every other PI, processed by the filter and played through the speaker:","title":"Filter Band"},{"location":"lfo_panner/","text":"Delay Ring Concept and programming: Max Weidauer More info coming soon.","title":"LFO Panner"},{"location":"lfo_panner/#delay-ring","text":"Concept and programming: Max Weidauer More info coming soon.","title":"Delay Ring"},{"location":"neighbors_spectral_phasor/","text":"Neighbour's Spectral Phaser Concept and programming: Jakob Tschavoll Circular network topology shown with 3 stations (1 station means 1 mic/instrument, 1 loudspeaker, 1 pi): Each participant's original audio generates continuous spectral centroids which are sent to the next participant via OSC messages. These values act as center frequencies for a notch gain filter running on each pi. This means, that one participant's fluctuating spectral content generates a fluctuating phaser effect ontheir neighbour's audio. This effect should have a dry/wet control to preserve the original sound but also the \"neighbour-generated\" filter settings.","title":"Neighbor's"},{"location":"neighbors_spectral_phasor/#neighbours-spectral-phaser","text":"Concept and programming: Jakob Tschavoll Circular network topology shown with 3 stations (1 station means 1 mic/instrument, 1 loudspeaker, 1 pi): Each participant's original audio generates continuous spectral centroids which are sent to the next participant via OSC messages. These values act as center frequencies for a notch gain filter running on each pi. This means, that one participant's fluctuating spectral content generates a fluctuating phaser effect ontheir neighbour's audio. This effect should have a dry/wet control to preserve the original sound but also the \"neighbour-generated\" filter settings.","title":"Neighbour's Spectral Phaser"},{"location":"p2psc/","text":"p2psc Peer 2 Peer Sound Control 1 is a software system for network music by Ben Wieder (TU/Neumann). It consists of the following components: Python Network Layer SuperCollider classes ansible-based deployment and configuration Network-Feedback Installation A use case for an interactive sound installation: wireless connection for wide range artistic exploration of network feedback Feedback network flow 1. Feedback network flow 2. Installation at ACUD, 2022: Reenacting Classics p2psc is a tool for reenacting concepts from the early days of network music - without a lot of setup and configuration: The Hub: Pioneers of Network Music (2022, L. Bruemmer [Ed.] ) Playing 'Waxlips' (The HUB, 1991): https://github.com/bontric/p2psc \u21a9","title":"p2psc"},{"location":"p2psc/#p2psc","text":"Peer 2 Peer Sound Control 1 is a software system for network music by Ben Wieder (TU/Neumann). It consists of the following components: Python Network Layer SuperCollider classes ansible-based deployment and configuration","title":"p2psc"},{"location":"p2psc/#network-feedback-installation","text":"A use case for an interactive sound installation: wireless connection for wide range artistic exploration of network feedback Feedback network flow 1. Feedback network flow 2. Installation at ACUD, 2022:","title":"Network-Feedback Installation"},{"location":"p2psc/#reenacting-classics","text":"p2psc is a tool for reenacting concepts from the early days of network music - without a lot of setup and configuration: The Hub: Pioneers of Network Music (2022, L. Bruemmer [Ed.] ) Playing 'Waxlips' (The HUB, 1991): https://github.com/bontric/p2psc \u21a9","title":"Reenacting Classics"},{"location":"round_robin/","text":"Round Robin Concept and programming: Max Weidauer p2psc is used to create messages, which travel along a circular topology.","title":"Round Robin"},{"location":"round_robin/#round-robin","text":"Concept and programming: Max Weidauer p2psc is used to create messages, which travel along a circular topology.","title":"Round Robin"},{"location":"scyclone/","text":"SCYCLONE Concept and programming: Valentin Ackva Network Topology XY-PAD Parameter Control Performance Concept","title":"SCYCLONE"},{"location":"scyclone/#scyclone","text":"Concept and programming: Valentin Ackva","title":"SCYCLONE"},{"location":"scyclone/#network-topology","text":"","title":"Network Topology"},{"location":"scyclone/#xy-pad","text":"","title":"XY-PAD"},{"location":"scyclone/#parameter-control","text":"","title":"Parameter Control"},{"location":"scyclone/#performance-concept","text":"","title":"Performance Concept"},{"location":"sprawl_2020/","text":"SPRAWL 2020 Basic Concept A local audio/metadata network system (von Coler et al., 2020) 2 : Any instrument can be connected to Access Points : Raspberry PI + audio interface HUB server for mixing and spatial rendering: OSC for control JackTrip for audio Free & open source 1 SuperCollider, PD, Faust Any musician has access to system parameters. The SPRAWL topology with server and access points. Designing and Testing Designed and built in a class with TU and CCRMA: Building the system in class. First tests in the TU studio. Typical setup with modular synth: Access Point with modular. Default remote screen. SPRAWL in Concert Concert with the EOC, TU students and various guests: 3D sound system on 3 levels audience can move freely Concert with SPRAWL at Silent Green (2020). View from the top. Students performing with SPRAWL. https://github.com/anwaldt/SPRAWL \u21a9 Henrik von Coler, Nils Tonn\u00e4tt, Vincent Kather, and Chris Chafe. Sprawl: a network system for enhanced interaction in musical ensembles. In Proceedings of the Linux Audio Conference . 2020. \u21a9","title":"SPRAWL 2020"},{"location":"sprawl_2020/#sprawl-2020","text":"","title":"SPRAWL 2020"},{"location":"sprawl_2020/#basic-concept","text":"A local audio/metadata network system (von Coler et al., 2020) 2 : Any instrument can be connected to Access Points : Raspberry PI + audio interface HUB server for mixing and spatial rendering: OSC for control JackTrip for audio Free & open source 1 SuperCollider, PD, Faust Any musician has access to system parameters. The SPRAWL topology with server and access points.","title":"Basic Concept"},{"location":"sprawl_2020/#designing-and-testing","text":"Designed and built in a class with TU and CCRMA: Building the system in class. First tests in the TU studio. Typical setup with modular synth: Access Point with modular. Default remote screen.","title":"Designing and Testing"},{"location":"sprawl_2020/#sprawl-in-concert","text":"Concert with the EOC, TU students and various guests: 3D sound system on 3 levels audience can move freely Concert with SPRAWL at Silent Green (2020). View from the top. Students performing with SPRAWL. https://github.com/anwaldt/SPRAWL \u21a9 Henrik von Coler, Nils Tonn\u00e4tt, Vincent Kather, and Chris Chafe. Sprawl: a network system for enhanced interaction in musical ensembles. In Proceedings of the Linux Audio Conference . 2020. \u21a9","title":"SPRAWL in Concert"},{"location":"system_boot/","text":"SPRAWL Notes User & Hostname Every PI has the same user name member Every PI has an individual hostname AP_XX Network Ethernet: switch with router and DHCP, nodes can be reached via hostnam. Wireless: each PI opens an individual WiFi. SSH enabled VNC/RDP enabled Installed Software jack aj-snapshot JackTrip SuperCollider sclang scsynth sc3-plugins PD (vanilla) Python3 python-osc Initial Setup of Pi Flash Rasperry Pi OS to a SD-Card, use these Settings in the RPi-Imager: set hostname: AP-XX (where XX is the associated number of the Pi) enable SSH, use password authentication set username and password Username: member Password: set locale settings (optional) Provisioning After boot, execute these playbooks to make it run ansible-playbook pi_setup/playbooks/install_ssh_key.yml --ask-pass -e \"key=path/to/public/key\" ansible-playbook pi_setup/playbooks/full_setup.yml Jacktrip Configuration Two options: One server on each PI, every PI has a client for each server (n Servers, n*n-1 clients) p2p connections between all PIs ((n*(n-1))/2 connections) Roll out (new) Pieces Stuff for pieces in one directory only: /home/member/pieces/piece_subdir Two options: Distribute code & binaries via ssh (ansible). Grab all code (& build binaries) via repositories (pull via ansible). Start and Stop Pieces System needs to be back in plain state after each piece. provide 'kill' playbooks","title":"SPRAWL Notes"},{"location":"system_boot/#sprawl-notes","text":"","title":"SPRAWL Notes"},{"location":"system_boot/#user-hostname","text":"Every PI has the same user name member Every PI has an individual hostname AP_XX","title":"User &amp; Hostname"},{"location":"system_boot/#network","text":"Ethernet: switch with router and DHCP, nodes can be reached via hostnam. Wireless: each PI opens an individual WiFi. SSH enabled VNC/RDP enabled","title":"Network"},{"location":"system_boot/#installed-software","text":"jack aj-snapshot JackTrip SuperCollider sclang scsynth sc3-plugins PD (vanilla) Python3 python-osc","title":"Installed Software"},{"location":"system_boot/#initial-setup-of-pi","text":"Flash Rasperry Pi OS to a SD-Card, use these Settings in the RPi-Imager: set hostname: AP-XX (where XX is the associated number of the Pi) enable SSH, use password authentication set username and password Username: member Password: set locale settings (optional)","title":"Initial Setup of Pi"},{"location":"system_boot/#provisioning","text":"After boot, execute these playbooks to make it run ansible-playbook pi_setup/playbooks/install_ssh_key.yml --ask-pass -e \"key=path/to/public/key\" ansible-playbook pi_setup/playbooks/full_setup.yml","title":"Provisioning"},{"location":"system_boot/#jacktrip-configuration","text":"Two options: One server on each PI, every PI has a client for each server (n Servers, n*n-1 clients) p2p connections between all PIs ((n*(n-1))/2 connections)","title":"Jacktrip Configuration"},{"location":"system_boot/#roll-out-new-pieces","text":"Stuff for pieces in one directory only: /home/member/pieces/piece_subdir Two options: Distribute code & binaries via ssh (ansible). Grab all code (& build binaries) via repositories (pull via ansible).","title":"Roll out (new) Pieces"},{"location":"system_boot/#start-and-stop-pieces","text":"System needs to be back in plain state after each piece. provide 'kill' playbooks","title":"Start and Stop Pieces"},{"location":"union/","text":"Union Concept and programming: Max Weidauer More info coming soon.","title":"UNION"},{"location":"union/#union","text":"Concept and programming: Max Weidauer More info coming soon.","title":"Union"}]}